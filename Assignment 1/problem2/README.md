# Problem 2

## Abstraction:

* Initial State:  a list of teams such that, Every student is in a team of 1 person, each team is a list itself
* State Space: set of all possible groupings of the students such that no team has more than 3 students
* Successor Function: for a given state generate all possible states that can be generated by combining any two teams such that no team has more than 3 people in it
 therefore if there are T teams at the current state then we have C(T,2) successors 
* Evaluation Function: cost function, gives the time required by the instructors if the current state is returned as the output


## Strategy Used: Local search
* the number of states can be very huge to search using search strategies like BFS or DFS
* There can be multiple goal states as any state can be a goal state and we need to return the best state we can find in a reasonable time


### Steepest Descent
When using steepest descent, at each state, we see the successor states and chose only the state that seems to be the best at this moment
Thus at each step we chose the succesor that has the minimum cost among all the successors
If no successors have a better cost than the current state, we can say that we have reached the local minima and break out of the loop

Since, we are not setting the initial state at random, and we know that we will reahch a local minima every time, or a state that has no successors, we can return a goal state at each time. Therefore we do not need to repeat the process k times to get a reasonable output.

### Monte Carlo Descent
In case of steepest descent, we only take the best successor at every step. This may lead to never reaching a better goal state if the path to it goes through some bad states.
Therefore, using randomness, we can argue that atleast some times we will get a result that is better than what we get from steepest descen
Thus we compare the result of various iterations and give the best result from all those iterations.

Also, since our steepest descent algorithm breaks only when it reaches a local minimum or a state with no successors, it can fail to give output tn a reasonable time when the input file has a large number of students.
In Monte Carlo descent we can set a value of depth that we can explore on each iteration and the number of iterations needed to get a result in a reasonable amount of time.

Monte Carlo descent can give a better result than steepest descent sometimes, and when it gives a poorer result, the cost difference is not too large.

### Comparing Monte Carlo Descent and Steepest Descent

* Monte Carlo Descent uses max_depth = 100 for 50 iterations using K = 160, M = 31, N = 10

| Number of Students | Time Using Monte Carlo | Monte Carlo Best Cost |Time using Steepest Descent | Steepest Descent Best Cost | 
| --- | ---| --- | --- | --- | 
| 6 | 0.024s | 342 | 0.032s | 342 | 
| 15 | 0.070s | 1053 | 0.036s | 1117 | 
| 20 | 0.112s | 1501 | 0.040s | 1609 |
| 50 | 2.080s | 4306 | 0.704s | 3654 |
| 100 | 30.864s | 8692 | 11.748s | 7563 |
| 200 | 7m37.064s | 21648 | 4m23.77s | 14166 |

* this table was generated by generating input files using the script provided by Johny Rufus on Piazza

As we can see from the table above, Monte carlo descent for max_depth = 100 and iterations = 50, gives the result for 100 students in a reasonable time, and provides better result than steepest descent in many cases.
But as the number of students increases the max_depth hinders the algorithm from searching beyond a depth of 100 resulting in a significantly poor cost.
Therefore, to get a state with better cost, we must use Monte Carlo Descent with a higher depth factor, but that would take a significantly longer amount of time.

Thus, for this problem, steepest descent algorithm is used by default to get a result in a reasonable amount of time.
to stop Steepest descent from exceeding this reasonable time (assumed 3:00 mins here), we can set a max_depth at which the steepest descent algorithm breaks. This can be thought of as Monte Carlo Descent with 1 iteration and a higher max_depth.
