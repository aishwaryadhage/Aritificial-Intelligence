#!/usr/bin/env python

#input format ./assign.py [input_file] [k] [m] [n]

"""
 For a detailed explanation of the choices kindly refer to the README.md file in the problem2 directory.
 The file can be found here: https://github.iu.edu/cs-b551-fa2017/adhage-akushwah-aarnav-a1/blob/master/problem2/README.md
"""

##initial state: a list of teams such that, Every student is in a team of 1 person, each team is a list itself

##state space: set of all possible groupings of the students such that no team has more than 3 students

##successor function: for a given state generate all possible states that can be generated by combining any two teams
# therefore if there are T teams at the current state then we have C(T,2) successors

#evaluation function: cost function, gives the time required by the instructors if current state is given as the output

##Strategy used: Local search 

#1 steepest descent (used for final submission)
#	at each step, find all successors of a given state
#	expand only the state that has the lowest cost
#	break if depth > max_depth or no successors have a better cost

#2 monte carlo descent
#	at each state find all successors
# 	if the cost of a successor is less than the current state chose that state
#	else chose the successor with a probability of e^((cost(s) - cost(s'))/t)
#	expand the successor 
#	repeat till some local minima is reached ie, no successors have cost < current state
#	repeat the process K times
#	chose the best result of K iterations

import sys
import random
import math

def readFile(filename):
	"""
	Reads the input file and returns a dictionary with preferences of students.
	"""
	student_dict ={}
	with open(filename, 'r') as f:
		l = f.readline()
		
		while l != "":
			student_id, team_size, want_list , avoid_list = l.strip().split(' ')
			student_dict[student_id] = {'team_size': int(team_size),
										'want': want_list.split(",") if want_list != "_" else [],
										'avoid': avoid_list.split(",") if avoid_list != "_" else []
										}
			l = f.readline()
	f.close() 
	return student_dict

def generateInitialState(responses):
	"""
	Returns a initial state
	A state where each team has only 1 student
	"""
	initialState = []
	for k,v in responses.iteritems():
		initialState.append([k])

	return initialState

def printOutput(state, cost=0):
	"""
	prints the goal state and the costin correct format
	"""
	for team in state:
		string = ' '.join(team)
		print string
	print cost
	return

def findCost(state, responses):
	"""
	given a state and student responses, return the number of minutes required by the instructors if this state is chosen as output 
	"""
	m = 0
	n = 0
	k = 0
	ts = 0
	want = 'want'
	avoid = 'avoid'
	for team in state:
		for student in team:
			for other in team:
				if other != student and other in responses[student][avoid]:
					m += 1
			for friend in responses[student][want]:
				if friend not in team:
					n += 1
			team_size = len(team)
			requested_team_size = responses[student]['team_size']
			if requested_team_size != team_size and requested_team_size != 0:
				ts += 1
		k +=1

	cost = K*k + M*m + N*n + ts
	return cost

def successors(state):
	"""
	Return all possible successors of the given state, generated by joining any 2 teams in the current state
	such that the resultant joined team has no more than 3 students
	"""
	successors = []
	teams = len(state)
	for i in range(teams):
		for j in range(i+1, teams):
			if len(state[i] + state[j]) <=3:
				new_state = state[:]
				new_state.append(state[i] + state[j])
				new_state.remove(state[i])
				new_state.remove(state[j])
				successors.append(new_state)

	return successors

def steepestDescent(initialState, max_depth = 150):
	"""
	at each step, find all successors of a given state
	expand only the state that has the lowest cost
	break if depth > max_depth or no successors have a better cost
	"""
	current =  initialState
	best_cost = findCost(initialState, responses)
	depth = 0
	while True:
		depth +=1
		successorList  = successors(current)
		if len(successorList) == 0:
			break

		costs = [findCost(s, responses) for s in successorList]
		new_best_cost = min(costs)
		if new_best_cost >= best_cost or depth > max_depth:
			break
		else:
			best_cost = new_best_cost
			current = successorList[costs.index(new_best_cost)]

	#returns goal state and cost
	return current, best_cost


def monteCarloDescent(initialState, iterations=50, T = 20, max_depth = 100):
	"""
	at each state find all successors
 	if the cost of a successor is less than the current state chose that state
	else chose the successor with a probability of e^((cost(s) - cost(s'))/t)
	expand the successor 
	repeat till some local minima is reached ie, no successors have cost < current state
	repeat the process K times
	chose the best result of K iterations

	"""
	
	best_sol = None
	best_cost = findCost(initialState, responses)
	
	for k in range(iterations):	
		current = initialState
		current_cost = findCost(initialState, responses)

		depth = 0
		while True:

			successorList = successors(current)
			depth += 1

			if depth > max_depth or len(successorList) == 0:
				break

			random_successor = random.choice(successorList)
			successor_cost = findCost(random_successor, responses)

			if successor_cost < current_cost:
				
				current = random_successor
				current_cost = successor_cost
			
			else:
				randnum = random.random()
				value = (current_cost - successor_cost)/T
				if randnum < math.exp(value):
					current = random_successor
					current_cost = successor_cost
						
		if current_cost< best_cost:
			best_cost = current_cost
			best_sol = current 
		
		T = T/10.0
	return best_sol , best_cost

if __name__ == '__main__':

	filename = str(sys.argv[1])
	K = int(sys.argv[2])
	M = int(sys.argv[3])
	N = int(sys.argv[4])

	responses = readFile(filename)
	
	initialState = generateInitialState(responses)
	goal, cost = steepestDescent(initialState)
	printOutput(goal,cost)
